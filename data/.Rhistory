xnew <- xold+sum(folds==i)-1
plot(y=inflation[xold:xnew],
x=c(1:nrow(df.train))[xold:xnew],
col=i, ylim=range(inflation), xlim=range(1:200))
par(new=TRUE)
xold <- xnew+1
}
par(new=FALSE)
warmIndex <- which(folds==1, arr.ind=TRUE) # length of warming up train set (this is always used as training set)
Yhat.valid <- numeric(nrow(df.train))      # store validation forecasts
Y.valid <- df.train$inflation.target       # real values
lambdas <- seq.int(0, 3, 0.01)                # ridge reg parameter
rmse <- matrix(numeric(length(lambdas)*k), ncol=length(lambdas))  # store rmse
pb <- txtProgressBar(min=1, max=length(rmse), style=3)
for (j in 1:length(lambdas)) {
for (i in 2:k) {
# Segment data by using which() function
validIndex <- which(folds==i, arr.ind=TRUE)
validData <- df.train[validIndex,]
trainIndex <- 1:(validIndex[1]-1)
trainData <- df.train[trainIndex,]
# Train
lm.1q <- lm.ridge(inflation.target ~ inflation.lag + unemp.lag + oil.lag, data=trainData, lambda=lambdas[j])
Yhat.valid[validIndex] <- as.matrix(validData[,-1]) %*% coef(lm.1q)[-1] + coef(lm.1q)[1]
# Compute validation error
error <- Yhat.valid[validIndex] - Y.valid[validIndex]
rmse[i,j] <- sqrt(mean(error^2))
}
# Update progress bar
setTxtProgressBar(pb, i*j+i)
close(pb)
}
rmse.valid <- colMeans(rmse)
plot(x=lambdas, y=rmse.valid)
lambda.hat <- lambdas[which.min(rmse.valid)]
Yhat.valid <- Yhat.valid[-warmIndex]
plot.ts(Yhat.valid, col='red', ylim=range(df.train$inflation.target))
par(new=TRUE)
plot.ts(df.train$inflation.target[-warmIndex], ylim=range(df.train$inflation.target))
k <- 26
folds <- cut(seq(1,nrow(df.train)), breaks=k, labels=FALSE)
xold <- 1
for (i in 1:k) {
xnew <- xold+sum(folds==i)-1
plot(y=inflation[xold:xnew],
x=c(1:nrow(df.train))[xold:xnew],
col=i, ylim=range(inflation), xlim=range(1:200))
par(new=TRUE)
xold <- xnew+1
}
par(new=FALSE)
warmIndex <- which(folds==1, arr.ind=TRUE) # length of warming up train set (this is always used as training set)
Yhat.valid <- numeric(nrow(df.train))      # store validation forecasts
Y.valid <- df.train$inflation.target       # real values
lambdas <- seq.int(0, 3, 0.01)                # ridge reg parameter
rmse <- matrix(numeric(length(lambdas)*k), ncol=length(lambdas))  # store rmse
pb <- txtProgressBar(min=1, max=length(rmse), style=3)
for (j in 1:length(lambdas)) {
for (i in 2:k) {
# Segment data by using which() function
validIndex <- which(folds==i, arr.ind=TRUE)
validData <- df.train[validIndex,]
trainIndex <- 1:(validIndex[1]-1)
trainData <- df.train[trainIndex,]
# Train
lm.1q <- lm.ridge(inflation.target ~ inflation.lag + unemp.lag + oil.lag, data=trainData, lambda=lambdas[j])
Yhat.valid[validIndex] <- as.matrix(validData[,-1]) %*% coef(lm.1q)[-1] + coef(lm.1q)[1]
# Compute validation error
error <- Yhat.valid[validIndex] - Y.valid[validIndex]
rmse[i,j] <- sqrt(mean(error^2))
}
# Update progress bar
setTxtProgressBar(pb, i*j+i)
close(pb)
}
rmse.valid <- colMeans(rmse)
plot(x=lambdas, y=rmse.valid)
lambda.hat <- lambdas[which.min(rmse.valid)]
errors
error
rmse
rmse[,1]
rmse[,10]
k <- 9
folds <- cut(seq(1,nrow(df.train)), breaks=k, labels=FALSE)
xold <- 1
for (i in 1:k) {
xnew <- xold+sum(folds==i)-1
plot(y=inflation[xold:xnew],
x=c(1:nrow(df.train))[xold:xnew],
col=i, ylim=range(inflation), xlim=range(1:200))
par(new=TRUE)
xold <- xnew+1
}
par(new=FALSE)
warmIndex <- which(folds==1, arr.ind=TRUE) # length of warming up train set (this is always used as training set)
Yhat.valid <- numeric(nrow(df.train))      # store validation forecasts
Y.valid <- df.train$inflation.target       # real values
lambdas <- seq.int(0, 3, 0.01)                # ridge reg parameter
rmse <- matrix(numeric(length(lambdas)*k), ncol=length(lambdas))  # store rmse
pb <- txtProgressBar(min=1, max=length(rmse), style=3)
for (j in 1:length(lambdas)) {
for (i in 2:k) {
# Segment data by using which() function
validIndex <- which(folds==i, arr.ind=TRUE)
validData <- df.train[validIndex,]
trainIndex <- 1:(validIndex[1]-1)
trainData <- df.train[trainIndex,]
# Train
lm.1q <- lm.ridge(inflation.target ~ inflation.lag + unemp.lag + oil.lag, data=trainData, lambda=lambdas[j])
Yhat.valid[validIndex] <- as.matrix(validData[,-1]) %*% coef(lm.1q)[-1] + coef(lm.1q)[1]
# Compute validation error
error <- Yhat.valid[validIndex] - Y.valid[validIndex]
rmse[i,j] <- sqrt(mean(error^2))
}
# Update progress bar
setTxtProgressBar(pb, i*j+i)
close(pb)
}
rmse.valid <- colMeans(rmse)
plot(x=lambdas, y=rmse.valid)
lambda.hat <- lambdas[which.min(rmse.valid)]
warmIndex <- which(folds==1, arr.ind=TRUE) # length of warming up train set (this is always used as training set)
Yhat.valid <- numeric(nrow(df.train))      # store validation forecasts
Y.valid <- df.train$inflation.target       # real values
lambdas <- seq.int(0, 5, 0.01)                # ridge reg parameter
rmse <- matrix(numeric(length(lambdas)*k), ncol=length(lambdas))  # store rmse
pb <- txtProgressBar(min=1, max=length(rmse), style=3)
for (j in 1:length(lambdas)) {
for (i in 2:k) {
# Segment data by using which() function
validIndex <- which(folds==i, arr.ind=TRUE)
validData <- df.train[validIndex,]
trainIndex <- 1:(validIndex[1]-1)
trainData <- df.train[trainIndex,]
# Train
lm.1q <- lm.ridge(inflation.target ~ inflation.lag + unemp.lag + oil.lag, data=trainData, lambda=lambdas[j])
Yhat.valid[validIndex] <- as.matrix(validData[,-1]) %*% coef(lm.1q)[-1] + coef(lm.1q)[1]
# Compute validation error
error <- Yhat.valid[validIndex] - Y.valid[validIndex]
rmse[i,j] <- sqrt(mean(error^2))
}
# Update progress bar
setTxtProgressBar(pb, i*j+i)
close(pb)
}
rmse.valid <- colMeans(rmse)
plot(x=lambdas, y=rmse.valid)
lambda.hat <- lambdas[which.min(rmse.valid)]
plot.ts(Yhat.valid, col='red', ylim=range(df.train$inflation.target))
par(new=TRUE)
plot.ts(df.train$inflation.target[-warmIndex], ylim=range(df.train$inflation.target))
plot.ts(Yhat.valid, col='red', ylim=range(df.train$inflation.target))
par(new=TRUE)
plot.ts(df.train$inflation.target[-warmIndex], ylim=range(df.train$inflation.target))
Yhat.valid <- Yhat.valid[-warmIndex]
plot.ts(Yhat.valid, col='red', ylim=range(df.train$inflation.target))
par(new=TRUE)
plot.ts(df.train$inflation.target[-warmIndex], ylim=range(df.train$inflation.target))
k <- 11
folds <- cut(seq(1,nrow(df.train)), breaks=k, labels=FALSE)
xold <- 1
for (i in 1:k) {
xnew <- xold+sum(folds==i)-1
plot(y=inflation[xold:xnew],
x=c(1:nrow(df.train))[xold:xnew],
col=i, ylim=range(inflation), xlim=range(1:200))
par(new=TRUE)
xold <- xnew+1
}
par(new=FALSE)
warmIndex <- which(folds==1, arr.ind=TRUE) # length of warming up train set (this is always used as training set)
Yhat.valid <- numeric(nrow(df.train))      # store validation forecasts
Y.valid <- df.train$inflation.target       # real values
lambdas <- seq.int(0, 5, 0.01)                # ridge reg parameter
rmse <- matrix(numeric(length(lambdas)*k), ncol=length(lambdas))  # store rmse
pb <- txtProgressBar(min=1, max=length(rmse), style=3)
for (j in 1:length(lambdas)) {
for (i in 2:k) {
# Segment data by using which() function
validIndex <- which(folds==i, arr.ind=TRUE)
validData <- df.train[validIndex,]
trainIndex <- 1:(validIndex[1]-1)
trainData <- df.train[trainIndex,]
# Train
lm.1q <- lm.ridge(inflation.target ~ inflation.lag + unemp.lag + oil.lag, data=trainData, lambda=lambdas[j])
Yhat.valid[validIndex] <- as.matrix(validData[,-1]) %*% coef(lm.1q)[-1] + coef(lm.1q)[1]
# Compute validation error
error <- Yhat.valid[validIndex] - Y.valid[validIndex]
rmse[i,j] <- sqrt(mean(error^2))
}
# Update progress bar
setTxtProgressBar(pb, i*j+i)
close(pb)
}
rmse.valid <- colMeans(rmse)
plot(x=lambdas, y=rmse.valid)
lambda.hat <- lambdas[which.min(rmse.valid)]
mean(error^2)
error^2
199/4
199-59
df.train
195/4
196/4
inflation.train.target[1:48]
plot(inflation.train.target[1:48])
dev.off()
plot(inflation.train.target[1:48])
dev.off()
library(MASS)
source('prem.R')
df.train
inflation
inflation.train.target
df.train
inflation
inflation.train.target
df.train
df.train[1:43,]
warmIndex <- 1:43
df.train[-warmIndex,]
nrow(df.train[-warmIndex,])
156/4
k <- nrow(df.train[-warmIndex,])
k
k <- nrow(df.train[-warmIndex,])/4
k
folds <- cut(seq(1,nrow(df.train[-warmIndex])), breaks=k, labels=FALSE)
folds
k <- nrow(df.train[-warmIndex,])/4 - 1
k
folds <- cut(seq(1,nrow(df.train[-warmIndex])), breaks=k, labels=FALSE)
folds
k <- nrow(df.train[-warmIndex,])/4 + 1
folds <- cut(seq(1,nrow(df.train[-warmIndex])), breaks=k, labels=FALSE)
folds
k <- nrow(df.train[-warmIndex,])/4 + 4
folds <- cut(seq(1,nrow(df.train[-warmIndex])), breaks=k, labels=FALSE)
folds
k <- nrow(df.train[-warmIndex,])/4 + 8
folds <- cut(seq(1,nrow(df.train[-warmIndex])), breaks=k, labels=FALSE)
folds
k
df.train[-warmIndex]
df.train[-warmIndex,]
nrow(df.train[-warmIndex,])
k <- nrow(df.train[-warmIndex,])/4 + 12
folds <- cut(seq(1,nrow(df.train[-warmIndex])), breaks=k, labels=FALSE)
folds
156/51
156/52
k <- nrow(df.train[-warmIndex,])/3
folds <- cut(seq(1,nrow(df.train[-warmIndex])), breaks=k, labels=FALSE)
folds
?cut
seq(1, nrow(df.train[-warmIndex])
)
seq(1, length(df.train[-warmIndex]))
seq(1, length(df.train$inflation.target[-warmIndex]))
folds <- cut(seq(1, length(df.train$inflation.target[-warmIndex])), breaks=k, labels=FALSE)
folds
k <- nrow(df.train[-warmIndex,])/4
folds <- cut(seq(1, length(df.train$inflation.target[-warmIndex])), breaks=k, labels=FALSE)
folds
for (i in 1:folds) {
print(sum(folds==i))
}
folds
folds[1]
folds[3]
max(folds)
for (i in 1:max(folds)) {
print(sum(folds==i))
}
warmIndex <- 1:43
df.warm <- df.train[-warmIndex,]
k <- nrow(df.train[-warmIndex,])/4
folds <- cut(seq(1, length(df.train$inflation.target[-warmIndex])), breaks=k, labels=FALSE)
for (i in 1:max(folds)) {
print(sum(folds==i))
}
Yhat.valid <- numeric(nrow(df.train[-warmIndex,]))      # store validation forecasts
Yhat.valid
df.train[-war,warmIndex]
df.train[-warmIndex]
df.train[-warmIndex,]
nrow(df.train[-warmIndex,])
folds
Y.valid <- df.train[-warmIndex]$inflation.target               # real values
Y.valid
Y.valid <- df.train[-warmIndex,]$inflation.target               # real values
Y.valid
lambdas <- seq.int(0, 5, 0.01)                     # ridge reg parameter
rmse <- matrix(numeric(length(lambdas)*k), ncol=length(lambdas))  # store rmse
pb <- txtProgressBar(min=1, max=length(rmse), style=3)
k
i=1
validIndex <- which(folds==i, arr.ind=TRUE)
validIndex
warmIndex
max(warmIndex)
which(folds==i, arr.ind=TRUE) + max(warmIndex)
validIndex[1]
Yhat.valid <- numeric(nrow(df.train))      # store validation forecasts
Y.valid <- df.train[-warmIndex,]$inflation.target  # real values
Yhat.valid
Y.valid
length(Y.valid)
length(Yhat.valid)
Yhat.valid <- numeric(nrow(df.train[-warmIndex,])) # store validation forecasts
Y.valid <- df.train[-warmIndex,]$inflation.target  # real values
lambdas <- seq.int(0, 5, 0.01)                     # ridge reg parameter
rmse <- matrix(numeric(length(lambdas)*k), ncol=length(lambdas))  # store rmse
pb <- txtProgressBar(min=1, max=length(rmse), style=3)
validIndex
validIndex <- which(folds==i, arr.ind=TRUE) + max(warmIndex)
i
validIndex <- which(folds==i, arr.ind=TRUE) + max(warmIndex)
validIndex
Yhat.valid <- numeric(nrow(df.train))      # store validation forecasts
Y.valid <- df.train$inflation.target  # real values
lambdas <- seq.int(0, 5, 0.01)                     # ridge reg parameter
rmse <- matrix(numeric(length(lambdas)*k), ncol=length(lambdas))  # store rmse
pb <- txtProgressBar(min=1, max=length(rmse), style=3)
for (j in 1:length(lambdas)) {
for (i in 1:k) {
# Segment data by using which() function
validIndex <- which(folds==i, arr.ind=TRUE) + max(warmIndex)
validData <- df.train[validIndex,]
trainIndex <- 1:(validIndex[1]-1)
trainData <- df.train[trainIndex,]
# Train
lm.1q <- lm.ridge(inflation.target ~ inflation.lag + unemp.lag + oil.lag, data=trainData, lambda=lambdas[j])
Yhat.valid[validIndex] <- as.matrix(validData[,-1]) %*% coef(lm.1q)[-1] + coef(lm.1q)[1]
# Compute validation error
error <- Yhat.valid[validIndex] - Y.valid[validIndex]
rmse[i,j] <- sqrt(mean(error^2))
}
# Update progress bar
setTxtProgressBar(pb, i*j+i)
close(pb)
}
rmse.valid <- colMeans(rmse)
plot(x=lambdas, y=rmse.valid)
plot(x=lambdas, y=rmse.valid)
lambda.hat <- lambdas[which.min(rmse.valid)]
Yhat.valid
Yhat.valid.trimmed <- Yhat.valid[-warmIndex]
plot.ts(Yhat.valid, col='red', ylim=range(df.train$inflation.target))
plot.ts(Yhat.valid.trimmed, col='red', ylim=range(df.train$inflation.target))
par(new=TRUE)
plot.ts(df.train$inflation.target[-warmIndex], ylim=range(df.train$inflation.target))
lm.1q.hat <- lm.ridge(inflation.target ~ inflation.lag + unemp.lag + oil.lag,
data=df.train, lambda=lambda.hat)
Yhat.train <- as.matrix(df.train[,-1]) %*% coef(lm.1q.hat)[-1] + coef(lm.1q.hat)[1]
Yhat.train <- as.matrix(df.train[,-1]) %*% coef(lm.1q.hat)[-1] + coef(lm.1q.hat)[1]
plot.ts(Yhat.train, col='Red')
par(new=TRUE)
plot(df.train$inflation.target, ylim=range(Yhat.train))
Yhat.train <- ts(Yhat,train, start=c(1948,1), end=c(1997,4))
Yhat.train <- as.matrix(df.train[,-1]) %*% coef(lm.1q.hat)[-1] + coef(lm.1q.hat)[1]
Yhat.train <- ts(Yhat.train, start=c(1948,1), end=c(1997,4))
plot(Yhat.train, col='Red')
par(new=TRUE)
plot(df.train$inflation.target, ylim=range(Yhat.train))
inflation.train.target
Yhat.train <- as.matrix(df.train[,-1]) %*% coef(lm.1q.hat)[-1] + coef(lm.1q.hat)[1]
Yhat.train <- ts(Yhat.train, start=c(1948,2), end=c(1997,4))
plot(Yhat.train, col='Red')
par(new=TRUE)
plot(df.train$inflation.target, ylim=range(Yhat.train))
Yhat.train
Yhat.train <- ts(Yhat.train, start=c(1948,2), end=c(1997,4), frequency=4)
Yhat.train
plot(Yhat.train, col='Red')
par(new=TRUE)
plot(df.train$inflation.target, ylim=range(Yhat.train))
Yhat.train
Yhat.train <- as.matrix(df.train[,-1]) %*% coef(lm.1q.hat)[-1] + coef(lm.1q.hat)[1]
Yhat.train
Yhat.train <- ts(Yhat.train, start=c(1948,2), end=c(1997,4), frequency=4)
Yhat.train
Yhat.train <- ts(Yhat.train, start=c(1948,2), end=c(1997,4), frequency=4)
plot(Yhat.train, col='Red')
par(new=TRUE)
plot(df.train$inflation.target, ylim=range(Yhat.train))
Yhat.test <- as.matrix(df.test[-1]) %*% coef(lm.1q.hat)[-1] + coef(lm.1q.hat)[1]
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)))
inflation.test.target
Yhat.test <- ts(Yhat.test, start=c(1998,2), end=c(2017,1))
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)))
Yhat.test <- ts(Yhat.test, start=c(1998,2), end=c(2017,1), frequency = 4)
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)))
Yhat.test <- as.matrix(df.test[-1]) %*% coef(lm.1q.hat)[-1] + coef(lm.1q.hat)[1]
Yhat.test <- ts(Yhat.test, start=c(1998,2), end=c(2017,1), frequency = 4)
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)))
Yhat <- numeric(76)
for (i in 1:76) {
if (i%%4==0) {#re-train after each year
lm.1q <- lm.ridge(inflation.target ~ inflation.lag + unemp.lag + oil.lag,
data=df.aug[100+i:(199+i-1),], lambda=150)
}
#Yhat[i] <- predict(lm.1q, newdata=df.test[i,])
Yhat[i] <- as.matrix(df.test[i,-1]) %*% coef(lm.1q.hat)[-1] + coef(lm.1q.hat)[1]
cat("Forecast:", Yhat[i], "Actual:", df.test$inflation.target[i], "\n")
plot.ts(Yhat[1:i], ylim=range(df.test$inflation.target), col='Red')
par(new=TRUE)
plot.ts(df.test$inflation.target[1:i], ylim=range(df.test$inflation.target), col='Black')
legend(x=0, y=0.5, legend=c("Forecast", "Actual"), lty=c(1,1), col=c('Red','Black'))
}
Yhat.test <- numeric(76)
for (i in 1:76) {
if (i%%4==0) {#re-train after each year
lm.1q <- lm.ridge(inflation.target ~ inflation.lag + unemp.lag + oil.lag,
data=df.aug[100+i:(199+i-1),], lambda=150)
}
#Yhat[i] <- predict(lm.1q, newdata=df.test[i,])
Yhat.test[i] <- as.matrix(df.test[i,-1]) %*% coef(lm.1q.hat)[-1] + coef(lm.1q.hat)[1]
cat("Forecast:", Yhat[i], "Actual:", df.test$inflation.target[i], "\n")
plot.ts(Yhat.test[1:i], ylim=range(df.test$inflation.target), col='Red')
par(new=TRUE)
plot.ts(df.test$inflation.target[1:i], ylim=range(df.test$inflation.target), col='Black')
legend(x=0, y=0.5, legend=c("Forecast", "Actual"), lty=c(1,1), col=c('Red','Black'))
}
Yhat.test <- ts(Yhat.test, start=c(1998,2), end=c(2017,1), frequency = 4)
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)))
Yhat.test <- numeric(76)
for (i in 1:76) {
if (i%%4==0) {#re-train after each year
lm.1q.hat <- lm.ridge(inflation.target ~ inflation.lag + unemp.lag + oil.lag,
data=df.aug[100+i:(199+i-1),], lambda=lambda.hat)
}
#Yhat[i] <- predict(lm.1q, newdata=df.test[i,])
Yhat.test[i] <- as.matrix(df.test[i,-1]) %*% coef(lm.1q.hat)[-1] + coef(lm.1q.hat)[1]
cat("Forecast:", Yhat[i], "Actual:", df.test$inflation.target[i], "\n")
plot.ts(Yhat.test[1:i], ylim=range(df.test$inflation.target), col='Red')
par(new=TRUE)
plot.ts(df.test$inflation.target[1:i], ylim=range(df.test$inflation.target), col='Black')
legend(x=0, y=0.5, legend=c("Forecast", "Actual"), lty=c(1,1), col=c('Red','Black'))
}
Yhat.test <- ts(Yhat.test, start=c(1998,2), end=c(2017,1), frequency = 4)
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)))
rm(list=ls())
dev.off()
source('C:/Users/Lim/Desktop/Dissertation/Models/RR/rr_1q_v2.R')
dev.off()
rm(list=ls())
source('C:/Users/Lim/Desktop/Dissertation/Models/RR/rr_1q_v2.R')
rm(list=ls())
dev.off()
source('C:/Users/Lim/Desktop/Dissertation/Models/RR/rr_1q_v2.R')
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), axis=FALSE)
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), axis='')
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), axis='')
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), labels='')
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), labels='')
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
dev.off()
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), labels='')
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), xlabel='')
dev.off()
Yhat.test <- ts(Yhat.test, start=c(1998,2), end=c(2017,1), frequency = 4)
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), xlabel='')
?plot
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), xlab='')
Yhat.test <- ts(Yhat.test, start=c(1998,2), end=c(2017,1), frequency = 4)
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)))
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), xlab='', ylab='')
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)),
ylab='Inflation',
main='Test Set')
par(new=TRUE)
plot(inflation.test.target, ylim=range(c(Yhat.test, inflation.test.target)), xlab='', ylab='')
plot.ts(Yhat.test, col='Red', ylim=range(c(Yhat.test, inflation.test.target)),
ylab='Inflation',
main='Test Set')
par(new=TRUE)
plot(df.test$inflation.target, ylim=range(c(Yhat.test, inflation.test.target)), xlab='', ylab='')
error.test <- Yhat.test - df.test$inflation.target
rmse.test <- sqrt(mean(error.test^2))
rmse.test
